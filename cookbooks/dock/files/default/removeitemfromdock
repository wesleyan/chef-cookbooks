#!/bin/bash
[ -f /tmp/debug ] && set -x
#############################
###                       ###
### Remove Item From Dock ###
###                       ###
#############################
#
# Simple utility, removes items from the dock.

#		12.9.28	Fixed 10.8 bug, Dock was using cached data from cfprefsd that did not read in new Dock despite disk changes. Now kills cfprefsd if 10.8
#		12.9.27	Fixed bug, when run as root would read com.apple.dock domain locally rather than specified path. Updated version scheme.
#		1.0.2	Bug fixes.
#		1.0.1	Added 100 item limit to dock items, in case something goes wrong and starts loop
#		1.0		Only restarts dock if something removed, if dock plist doesn't exist exits better version number
#		0.0.6   Added -f option to specify file path (useful for altering default.plist in Dock.app)
#		0.0.5	Fixed Dashboard hack with another hack
#		0.0.4	Trim trailing / on item names
#		0.0.3 	Added log abilities
#		0.0.2 	Changed coding style from `` to $()
#		0.0.1	Bug fixes, making it work!

# (C)2010 Joel Bruner GNU GPL
# Based off of code from additemtodock (C)2006 Henri Shustak GNU GPL

function check_arguments {

    if [ "$num_argumnets" -lt "1" ] ; then
        echo "ERROR: No arguments provided. Nothing removed from the Dock."
		echo "Example: removeitemfromdock [-f dockfile] /Applications/Mail.app ..."
         
        exit_status=2
        exit_now
    fi
    
    return 0
}

function exit_now
{
    exit $exit_status
}

function sendlog
{
input=${1}

#system.log
logger -t "$scriptName [$$]" $input
#seperate update log
echo $input
}

function check_is_item_in_dock {

itemType=$1

#check for item
dockItemList=$(defaults read $plistpath $itemType | grep -w _CFURLString | awk 'BEGIN { FS = "\"" } ; { print $4 }' | sed 's/%20/ /g')
application_check1=$(echo "$dockItemList" | grep "${item2remove}")

#Dashboard hack
#might match above if added again using additemtodock, but Apple's way of adding does not use _CFURLString
if [ -z "$application_check1" -a "${item2remove}" == "/Applications/Dashboard.app" ]; then
	application_check1=$(defaults read $plistpath persistent-apps | grep dashboard-tile | awk 'BEGIN { FS = "\"" } ; { print $4 }')
	# This application is in the dock
	[ "$application_check1" == "dashboard-tile" ] && return 0  
fi

# This application is in the dock
# set item2remove to what is found
if [ ! -z "${application_check1}" ]; then
	item2remove=${application_check1}
else
    sendlog "NOT FOUND: ${item2remove}"
    # This application is not in the dock 
    return 1
fi

}

function removeItem {

#argument passed: persistent-others or persistent-app
itemType=$1

for (( dockitem=0; dockitem < 100; dockitem++ )); do 

	# Dashboard hack it's the only app on the left of the dock that doesn't doesn't have a _CFURLString
	tiletype=$($myPlistBuddy -c "print $itemType:$dockitem:tile-type" $filepath 2> /dev/null);
	
	if [ "$tiletype" == "dashboard-tile" ]; then
		candidate="/Applications/Dashboard.app"
	else
		candidate=$($myPlistBuddy -c "print $itemType:$dockitem:tile-data:file-data:_CFURLString" $filepath | sed 's/%20/ /g'); 
	fi
	
	#echo item2remove: "${item2remove}" cadidate: "${candidate}"
	if [ "${item2remove}" == "${candidate}" ]; then 
		$myPlistBuddy -c "delete $itemType:$dockitem" $filepath; let removed++;
		sendlog "FOUND and Removed item $dockitem: ${item2remove}"
		break
	elif [ -z "$candidate" ] || [[ "$candidate" == *Does\ Not\ Exist ]]; then 
		#keep from running on in case of error
		#old plistBuddy returns strings to stdout, newer versions do not
		break
	fi
done
}


function check_is_application {
        
    extension=$(basename "${item2remove}" | tail -c 5)
    if [ "${extension}" == ".app" ] ; then 
        # This item is an Application
        return 1
    fi
    
    #use file to determine if executable PEF files don't have .app extensions
    file "${item2remove}" | grep -q executable 
    if [ $? -eq 0 ]; then
    	# This item is an Application
    	return 1
	fi    
    
    # This item is not an Application
    return 0
}

function check_dock_status {
#if there is no console user then this is irrelevant since Dock will not be running
consoleUsers=$(who | grep -c console)
#return from function
[ ${consoleUsers:=0} -eq 0 ] && return

#see how long the dock has been running or if it is running at all and wait
#otherwise this script goes to fast when run in rapid succession and the killall Docks obliterate the changes
dockLife=$(ps axww -O etime | grep /MacOS/[D]ock | awk '{print $2}')
echo DockLife=$dockLife
case ${dockLife:=0} in

#Days
#??-??:??:??)
#;;
#Hours
#??:??:??)
#
#;;

#Minutes
??:??)
dockMinutes=${dockLife:0:2}
dockSeconds=${dockLife:3:2}

#if the dock has been alive for less than 2 seconds wait from 2-4 seconds more
if [ $dockMinutes -eq 0 -a $dockSeconds -lt 3 ]; then
waitTime=$(( 5 - $dockSeconds ))
echo Waiting $dockSeconds seconds
sleep $waitTime
fi
;;

#zero, the dock was killed just now
0)
sleep 5

esac
}

########### LOGIC AND EXECUTION ###########
#allow folders and files with spaces
IFS=$'\t\r'

#OS X version check
long_version=`sw_vers | grep ProductVersion | awk {'print $2'}`
#OS X version check
long_version=$(sw_vers | grep ProductVersion | awk {'print $2'})
majorVersion=$(echo $long_version | cut -d . -f 1)
minorVersion=$(echo $long_version | cut -d . -f 2)

#set OS specific things, DSCL path and PlistBuddy location
if [ $minorVersion -eq 4 ]; then
myPlistBuddy="/Library/Receipts/iTunesX.pkg/Contents/Resources/PlistBuddy"
elif [ $minorVersion -ge 5 ]; then
myPlistBuddy="/usr/libexec/PlistBuddy"
fi

scriptName=$(basename $0)

# General Settings
num_argumnets=$#
exit_status=0

check_dock_status

# Check we are good to go
check_arguments

	if [ "$1" == '-f' -a -f "$2" ]; then
	#set path to 2nd argument
	filepath="$2"
	plistpath=$(echo $filepath | sed 's/.plist//')
	#skip arguments in the for loop
	shift 2
	elif [ "$1" == '-f' -a ! -f "$2" ]; then
		echo "ERROR: invalid file path provided"
		echo "Example: removeitemfromdock [-f filepath] /Applications/Mail.app ..."
        exit_status=2
        exit_now
	else
    	filepath=~/Library/Preferences/com.apple.dock.plist
	    plistpath=com.apple.dock
	    if [ ! -f $filepath ]; then
	    logger "NOT FOUND, EXITING: ~/Library/Preferences/com.apple.dock.plist"
		    exit 0
	    fi
	fi

sendlog "Dock file is: $filepath"

# Loop Though the arguments provided.

for a in $@
do
    
    #item2remove="$a"
    #trim trailing /
	item2remove=$(dirname "${a}")/$(basename "${a}")
	#trim leading // for root items
	item2remove=${item2remove/\/\//\/}

    sendlog "Looking for: ${item2remove}"

    check_is_application
    if [ $? == 1 ] ; then
        check_is_item_in_dock persistent-apps
        [ $? == 0 ] && removeItem persistent-apps
    else
        check_is_item_in_dock persistent-others
        [ $? == 0 ] && removeItem persistent-others
    fi

done

# Restarts the Dock
if [ ! -z "$removed" ]; then
[ $minorVersion -eq 8 ] && killall cfprefsd
sleep 1
killall Dock
sleep 1
fi

exit_status=0
exit_now
